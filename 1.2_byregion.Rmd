---
title: "1.2_byregion"
output: html_document
date: "2023-02-15"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


**This markdown goes through the initial filtering stages for Pocillopora meandrina using Dartseq data BY SECTOR within regions (GBR and Coral Sea)** 

#Load libraries
```{r, include = FALSE}
library(dartR)
library(adegenet)
library(poppr)
library(hierfstat)
library(reshape2)
library(ggplot2)
library(RColorBrewer)
library(scales)
library(dplyr)
```

#Load data
```{r}
gl <- gl.read.dart(filename = "Report_DPoc22-7167_SNP_mapping_2.csv", covfilename = "CSMP.GBR/Pmeandrina_dartLIMS_sector.csv")
#saveRDS(gl, file="gl.Rdata") 

#dropping individuals that were falsely ID'd as P. meandrina 
gl <- gl.drop.ind(gl,
   ind.list=c('JAN2019_13-124_P. verrucosa_103', 'April2021-Kelso-P. verrucosa-17','P ver 221', 'P ver 371', 'P ver 372', 'P ver 291', 'P ver 044'))


#we know that 62 total samples failed, so this makes sense that we only have 115 / 188 individuals recognised in our data frame. 
```

# Check metadata 
```{r}
nInd(gl)
#110 individuals

nLoc(gl)
#43980 loci in the original dataset (gl)

nPop(gl)

popNames(gl)

#converting SNP files to a matrix 
#generate a matrix of the SNP scores, with 0 as homozygous reference, 2 as homozygous alternate and 1 as heterozygous
m <- as.matrix(gl)

indNames(gl)
```

#1. Filtering Steps 

##1.1 Filter secondaries
```{r}
#First we are filtering SNP call rate typically at 95 % threshold to make a confident call on genotype. 
#we need to decide whether it's better to filter by individual or by locus first. We agree it is better to lose loci in this case than to lose individuals, so we will filter by loci first. Indicated by method = "loc"
# We are basically calculating the percentage of complete genotypes per loci in the entire dataset for Acropora. 


#filter out secondaries (all but one SNP retained per sequence tag)
gl <- gl.filter.secondaries(gl)

nLoc(gl)
#now we have 27,253 loci 
```

##1.2 Filter reproducibility 
```{r}
gl.report.reproducibility(gl)

#filter loci with reproducibility below a particular threshold
gl <- gl.filter.reproducibility(gl, threshold = 0.98)

nLoc(gl)
#21.975
```

##1.3 Filter call rate
```{r}
#filter loci with >20% missing data. we lose way too many loci for the regional trends if we filter by call rate > 95% so 80% gives sufficient loci to work with. 
gl2 <- gl.filter.callrate(gl, method = "loc", threshold = 0.80)
nLoc(gl2)

#provide a summary of the call rate values
gl.report.callrate(gl2) 
```

##1.4 Filter read depth
```{r}
#filter read depth < 5x
gl2 <- gl.filter.rdepth(gl2, lower = 5, upper = 200, verbose = 3)

nLoc(gl2)
#3624
```


##1.5 Filter MAFs
```{r}
#We will filter out loci with a MAF less than 0.05.**
gl3 <- gl.filter.maf(gl2, threshold = 0.95) 

#report for MAF after filtering with MAF < 0.05 
gl.report.maf(gl3)
nLoc(gl3)
#1957 snps remaining 
```

##1.6 Impute missing data 
```{r, include = FALSE}
#here we are imputing any missing data using the 'neighbour' method. this is essential for some analyses later on to not have missing data 
gl3 <- gl.impute(
  gl3,
  method = "neighbour",
  fill.residual = TRUE,
  parallel = FALSE,
  verbose = NULL
)
```


#2. Additional Filtering 

##2.1 Convert to genind 
```{r}
#converting a genlight object (we have) to a genind object so we can look at genetic data at an individual data using adegenet package. 
pmea_gen <- gl2gi(gl3, probar = FALSE, verbose = NULL)
pmea_gen

is.genind(pmea_gen)
```

##2.2 Check relatedness
```{r}
#here we are checking for any clones / duplicate samples. We want to remove any that are. 
#check genotypes are unique
mlg(pmea_gen)

#so we don't have any clones 
```

##2.3 Check monomorphic loci 
```{r}
#check that loci are still polymorphic after filtering. Retaining monomorphic loci unnecessarily increases the size of the dataset and will affect some calculations.

isPoly(pmea_gen) %>% summary

#remove loci that are not polymorphic 

poly_loci = names(which(isPoly(pmea_gen) == TRUE))
pmea_gen = pmea_gen[loc = poly_loci]
isPoly(pmea_gen) %>% summary
```

#reading in files with population level 
```{r}
gl.pop <- gl.read.dart(filename = "Report_DPoc22-7167_SNP_mapping_2.csv", covfilename = "CSMP.GBR/Pmeandrina_dartLIMS_pop.csv")
#saveRDS(gl, file="gl.Rdata") 

gl.pop <- gl.drop.ind(gl.pop,
   ind.list=c('JAN2019_13-124_P. verrucosa_103', 'April2021-Kelso-P. verrucosa-17','P ver 221', 'P ver 371', 'P ver 372', 'P ver 291', 'P ver 044'))

popNames(gl.pop)

m <- as.matrix(gl.pop)
gl.pop <- gl.filter.secondaries(gl.pop)
gl.pop <- gl.filter.reproducibility(gl.pop, threshold = 0.98)
gl2.pop <- gl.filter.callrate(gl.pop, method = "loc", threshold = 0.80)
gl2.pop <- gl.filter.rdepth(gl2.pop, lower = 5, upper = 200, verbose = 3)
gl3.pop <- gl.filter.maf(gl2.pop, threshold = 0.95) 

gl3.pop <- gl.impute(
  gl3.pop,
  method = "neighbour",
  fill.residual = TRUE,
  parallel = FALSE,
  verbose = NULL
)

```

```{r}
#converting a genlight object (we have) to a genind object so we can look at genetic data at an individual data using adegenet package. 
pmea_gen.pop <- gl2gi(gl3.pop, probar = FALSE, verbose = NULL)
pmea_gen.pop

is.genind(pmea_gen.pop)
```

##2.3 Check monomorphic loci 
```{r}
#check that loci are still polymorphic after filtering. Retaining monomorphic loci unnecessarily increases the size of the dataset and will affect some calculations.

isPoly(pmea_gen.pop) %>% summary

#remove loci that are not polymorphic 

poly_loci = names(which(isPoly(pmea_gen.pop) == TRUE))
pmea_gen.pop = pmea_gen.pop[loc = poly_loci]
isPoly(pmea_gen.pop) %>% summary
```

#3. Genetic diversity statistics

## 3.1 Heterozygosity (Ho)
```{r}
#Here we are calculating basic stats using hierfstat
basic_pmea = basic.stats(pmea_gen, diploid = TRUE)

# Mean observed heterozygosity per site
Ho_pmea = apply(basic_pmea$Ho, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
  round(digits = 2)
Ho_pmea
```


```{r}
# Function to calculate observed or expected heterozygosity for a given number of individuals
calculate_heterozygosity <- function(data, n, diploid = TRUE) {
  # Randomly select 'n' rows (individuals) from the data
  indices <- sample(nrow(data), size = n)
  sub_sample <- data[indices, ]
  
  # Calculate basic stats using hierfstat on the sub-sample
  basic_stats <- hierfstat::basic.stats(sub_sample, diploid = diploid)
  
  # Calculate mean observed heterozygosity per site
  ho <- apply(basic_stats$Ho, MARGIN = 2, FUN = mean, na.rm = TRUE)
  
  return(ho)
}

# Example usage:
# Assuming 'pmea_gen' is your data and 'n' is the number of individuals to be sampled
#n <- 5  # Number of individuals to be sampled
#ho_pmea <- calculate_heterozygosity(pmea_gen@tab, n, diploid = TRUE)
#ho_pmea
```


## 3.2 Heterozygosity (He)
```{r}
# Mean expected heterozygosity per site
He_pmea = apply(basic_pmea$Hs, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
  round(digits = 2)
He_pmea

# Create a data.frame of site names, Ho and He and then convert to long format
Het_pmea_df = data.frame(Site = names(Ho_pmea), Ho = Ho_pmea, He = He_pmea) %>%
  melt(id.vars = "Site")
```

## 3.3 Plot He/Ho
```{r}
# Custom theme for ggplot2
custom_theme = theme(
  axis.text.x = element_text(size = 10, angle = 90, vjust = 0.5, face = "bold"),
  axis.text.y = element_text(size = 10),
  axis.title.y = element_text(size = 12),
  axis.title.x = element_blank(),
  axis.line.y = element_line(size = 0.5),
  legend.title = element_blank(),
  legend.text = element_text(size = 12),
  panel.grid = element_blank(),
  panel.background = element_blank(),
  plot.title = element_text(hjust = 0.5, size = 15, face="bold")
  )

# Italic label
hetlab.o = expression(italic("H")[o])
hetlab.e = expression(italic("H")[e])

# Acropora heterozygosity barplot
ggplot(data = Het_pmea_df, aes(x = Site, y = value, fill = variable))+
  geom_bar(stat = "identity", position = position_dodge(width = 0.6), colour = "black")+
  scale_y_continuous(expand = c(0,0), limits = c(0,0.15), breaks = c(0, 0.05, 0.10))+
  scale_fill_manual(values = c("pink", "#bdbdbd"), labels = c(hetlab.o, hetlab.e))+
  ylab("Heterozygosity")+
  ggtitle("P. meandrina")+
  custom_theme
```

##3.4 Inbreeding (Fis)
```{r}
#Looking at Fis values. A high Fis implies considerable degree of inbreeding 
apply(basic_pmea$Fis, MARGIN = 2, FUN = mean, na.rm = TRUE) %>%
  round(digits = 3)

```



##3.5 Isolation by distance models
```{r}
ibd <- gl.ibd(gl3, Dgeo_trans='log(Dgeo)' ,Dgen_trans='Dgen/(1-Dgen)')
```

##3.6 Calculate Fst
```{r}
#using hierfstat package here. 
#compute pairwise Fst values. Returns pairwise distances folloiwng Weir & Cockerham 1984 
pmea_fst = genet.dist(pmea_gen, method = "WC84") %>% round(digits = 3)
pmea_fst
```



##3.7 Subsample Fsts
**Here, we want to make sure that disparities in sample sizes are not causing Fsts to be overestimated** 


##3.8 Figure 1b (Fst)
```{r}
library(RColorBrewer)

# Relevel reefs by GBR, CSMP, and latitude 
lab_order = c("PCB", "Townsville", "Swains", "CapBunk", "CS1","CS2", "CS3", "CS4","CS5", "CS6")


colors <-  c("#D73027", "#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", "#D9EF8B", "#A6D96A", "#66BD63")

# Change order of rows and cols
fst.mat = as.matrix(pmea_fst)
fst.mat1 = fst.mat[lab_order, ]
fst.mat2 = fst.mat1[, lab_order]

# Create a data.frame
ind = which(upper.tri(fst.mat2), arr.ind = TRUE)
fst.df = data.frame(Site1 = dimnames(fst.mat2)[[2]][ind[,2]],
                    Site2 = dimnames(fst.mat2)[[1]][ind[,1]],
                    Fst = fst.mat2[ ind ])

# Keep the order of the levels in the data.frame for plotting 
fst.df$Site1 = factor(fst.df$Site1, levels = unique(fst.df$Site1))
fst.df$Site2 = factor(fst.df$Site2, levels = unique(fst.df$Site2))
fst.df$Fst[fst.df$Fst < 0] = 0
fst.df %>% str
fst.label = expression(italic("F")[ST])
mid = max(fst.df$Fst) / 2

# Plot heatmap
ggplot(data = fst.df, aes(x = Site1, y = Site2, fill = Fst)) +
  geom_tile(colour = "black") +
  # geom_text(aes(label = Fst), color="black", size = 3)+
  scale_fill_gradientn(
    colours = c("#66BD63", "#FFFFBF", "#D73027"),
    limits = c(0, .17),
    breaks = c(0, 0.09, 0.18),
    guide = "colorbar"
  ) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0), position = "right") +
  theme(
    axis.text = element_text(colour = "black", size = 10, face = "bold"),
    axis.title = element_blank(),
    axis.text.x = element_text(angle = 45, vjust = 0.5),
    panel.grid = element_blank(),
    panel.background = element_blank(),
         legend.position = c(0.15, 0.7),  # Adjust the coordinates (x, y) here
    legend.title = element_text(size = 14, face = "bold"),
    legend.text = element_text(size = 10),
    legend.direction = "horizontal"
  ) +
  coord_fixed(ratio = 0.9)
```

```{r}
library("apex")
library("adegenet")
library("pegas")
library("mmod")
library("poppr")

```


##3.9 AMOVA for population Fsts 
```{r}

# Import strata
my_strata <- read.csv("CSMP.GBR/pmea_strata.csv") %>% 
  dplyr::select(Ind, Pop, Region, Sector) 

#define strata file in genind
strata(pmea_gen) <- my_strata
setPop(pmea_gen) <-~Sector
pmea_gen
```

```{r}
# AMOVA
amova.sector <- poppr.amova(pmea_gen , ~Sector,  within = T) 
amova.sector
# this is to use populations as lowest level

amova.sector_sig <- randtest(amova.sector, nrepet = 999)

# This was done with no correction method though!

amova.sector_sig
plot(amova.sector_sig)

#most of the variation occurs within samples, but we also have a lot of variation between samples. 
#while there is variation between sectors, there is not a lot, and suggests relatively panmictic populations. 
```





#4. PCA

##4.1 PCA model 
```{r}
x = tab(pmea_gen, NA.method = "mean")

# Perform PCA
pca1 = dudi.pca(x, scannf = FALSE, scale = FALSE, nf = 3)

# Analyse how much percent of genetic variance is explained by each axis
percent = pca1$eig/sum(pca1$eig)*100
barplot(percent, ylab = "Genetic variance explained by eigenvectors (%)", ylim = c(0,12),
        names.arg = round(percent, 1))
```


##4.2 PCA coord dataframe 
```{r}
# Create a data.frame containing individual coordinates
ind_coords = as.data.frame(pca1$li) 

# Rename columns of dataframe
colnames(ind_coords) = c("Axis1","Axis2","Axis3")

# Add a column containing individuals
ind_coords$Ind = indNames(pmea_gen)

# Add a column with the site IDs
ind_coords$Site = pmea_gen$pop

# Calculate centroid (average) position for each population
centroid = aggregate(cbind(Axis1, Axis2, Axis3) ~ Site, data = ind_coords, FUN = mean)

# Add centroid coordinates to ind_coords dataframe
ind_coords = left_join(ind_coords, centroid, by = "Site", suffix = c("",".cen"))

# Define colour palette
cols = brewer.pal(nPop(pmea_gen), "Set3")

# Custom x and y labels
xlab = paste("Axis 1 (", format(round(percent[1], 1), nsmall=1)," %)", sep="")
ylab = paste("Axis 2 (", format(round(percent[2], 1), nsmall=1)," %)", sep="")
```


##4.3 PCA metadata 
```{r}
pmea.meta <- read.csv("CSMP.GBR/Pmeandrina_meta.csv") 

ind_coords.full <- ind_coords %>% left_join(pmea.meta) %>% 
  mutate(pop = as.factor(pop)) %>% 
  mutate(region = as.factor(region)) 

#define colour palette for each reef. 
reef_names <- c("CapeGrenville", "PCB", "Cairns", "Townsville", "Swains", "CapBunker", "CS1", "CS2", "CS3", "CS4", "CS5", "CS6")
reef_pal <- c("#9E0142", "#D53E4F", "#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", 
              "#C51B7D", "#5E4FA2", "#3288BD","#66C2A5","#ABDDA4","#E6F598")

names(reef_pal) <- reef_names
```


#PCA with environment
```{r}
pmea.meta <- read.csv("pmea.meta2.csv")

ind_coords.full <- ind_coords %>% left_join(pmea.meta) %>% 
  mutate(sector = as.factor(sector)) %>% 
  mutate(region = as.factor(region)) 
```

##4.4 Theme for PCA
```{r}
theme_PCA <-theme(aspect.ratio = 3/5) +
  theme(axis.line = element_blank()) +
  theme(plot.background = element_blank(),
    panel.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
 theme(panel.border = element_rect(colour = "black", fill=NA, size=1))
```

##4.5 Plot PCA by sector
```{r}
ind_coords.full

ind_coords.full <- ind_coords.full %>% mutate(sector = factor(sector, levels = c("CapeGrenville", "PCB", "Cairns", "Townsville", "Swains", "CapBunker", "CS1", "CS2", "CS3", "CS4", "CS5", "CS6")))


PCA <- ind_coords.full %>% 
  ggplot(aes(Axis1, Axis2, fill = sector)) +
  geom_point(alpha = 1, shape = 21, size = 2) + 
  scale_fill_manual(values = reef_pal) +
  labs(x = xlab, y = ylab) +
  theme_PCA

PCA
```

##4.6 Plot PCA by latitude
```{r}
PCA.lat <- ind_coords.full %>% 
  ggplot(aes(Axis1, Axis2, fill = lat)) +
  geom_point(alpha = 1, shape = 21, size = 2) + 
  scale_fill_distiller(palette = "Spectral", trans = "reverse") +
  labs(x = xlab, y = ylab) +
  theme_PCA

PCA.lat
```


##4.7 Plot PCA by longitude
```{r}
PCA.lon <- ind_coords.full %>% 
  ggplot(aes(Axis1, Axis2, fill = lon)) +
  geom_point(alpha = 1, shape = 21, size = 2) + 
  scale_fill_distiller(palette = "BrBG", trans = "reverse") +
  labs(x = xlab, y = ylab) +
  theme_PCA

PCA.lon
```
**Anything really high or low longitude seems to be in the two distinct clusters. 


##4.8 Plot PCA by region
```{r}
mycols <- c("#E6F598", "#66C2A5")

PCA.sector <- ind_coords.full %>% 
  ggplot(aes(Axis1, Axis2, fill = region)) +
  geom_point(alpha = 1, shape = 21, size = 2) + 
  scale_fill_manual(values = mycols) +
  labs(x = xlab, y = ylab) +
  theme_PCA

PCA.sector
```


##4.9 Plot PCA by MMM
```{r}
PCA.MMM <- ind_coords.full %>% 
  ggplot(aes(Axis1, Axis2, fill = MMM)) +
  geom_point(alpha = 1, shape = 21, size = 2) + 
  scale_fill_distiller(palette = "Spectral") +
    # custom labels
  labs(x = xlab, y = ylab) +
  theme_PCA

PCA.MMM
```
##4.10 Plot PCA by depth
```{r}
PCA.depth <- ind_coords.full %>% 
  ggplot(aes(Axis1, Axis2, fill = depth)) +
  geom_point(alpha = 1, shape = 21, size = 2) + 
  scale_fill_distiller(palette = "BrBG", trans = "reverse") +
  labs(x = xlab, y = ylab) +
  theme_PCA

PCA.depth
```

##4.11 Figure 3A
```{r}
PCA.sector / PCA.lon / PCA.lat
```


#5. DAPC 

##5.1 Cross validation 
```{r}
# Perform cross validation to find the optimal number of PCs to retain in DAPC
x = tab(pmea_gen, NA.method = "mean")
crossval = xvalDapc(x, pmea_gen$pop, result = "groupMean", xval.plot = TRUE)
```

##5.2 Identify DAPC parameters
```{r}
# Number of PCs with best stats (lower score = better)
crossval$`Root Mean Squared Error by Number of PCs of PCA`
 #      10        20        30        40        50        60        70        80 
# 0.8405259 0.8350323 0.8100512 0.8108793 0.8296289 0.8008756 0.8417127 0.8640549 
crossval$`Number of PCs Achieving Highest Mean Success`
## [1] "60"
crossval$`Number of PCs Achieving Lowest MSE`
## [1] "60"
numPCs = as.numeric(crossval$`Number of PCs Achieving Lowest MSE`)
```

##5.2 Run DAPC
```{r}
# Run a DAPC using site IDs as priors
dapc1 = dapc(pmea_gen, pmea_gen$pop, n.pca = numPCs, n.da = 3)

# Analyse how much percent of genetic variance is explained by each axis
percent = dapc1$eig/sum(dapc1$eig)*100
barplot(percent, ylab = "Genetic variance explained by eigenvectors (%)", ylim = c(0,60),
        names.arg = round(percent, 1))
```


## 5.3 Visualise DAPC plot
```{r}
# Create a data.frame containing individual coordinates
ind_coords.dapc = as.data.frame(dapc1$ind.coord)

# Rename columns of dataframe
colnames(ind_coords.dapc) = c("Axis1","Axis2","Axis3")

# Add a column containing individuals
ind_coords.dapc$Ind = indNames(pmea_gen)

# Add a column with the site IDs
ind_coords.dapc$Site = pmea_gen$pop

# Calculate centroid (average) position for each population
centroid = aggregate(cbind(Axis1, Axis2, Axis3) ~ Site, data = ind_coords.dapc, FUN = mean)

# Add centroid coordinates to ind_coords dataframe
ind_coords.dapc = left_join(ind_coords.dapc, centroid, by = "Site", suffix = c("",".cen"))

# Define colour palette
cols = brewer.pal(nPop(pmea_gen), "Spectral")

# Custom x and y labels
xlab.dapc = paste("Axis 1 (", format(round(percent[1], 1), nsmall=1)," %)", sep="")
ylab.dapc = paste("Axis 2 (", format(round(percent[2], 1), nsmall=1)," %)", sep="")

ind_coords.dapc <- ind_coords %>% mutate(sector = factor(sector, levels = c("CapeGrenville", "PCB", "Cairns", "Townsville", "Swains", "CapBunker", "CS1", "CS2", "CS3", "CS4", "CS5", "CS6")))

# Scatter plot axis 1 vs. 2
ggplot(data = ind_coords.dapc, aes(x = Axis1, y = Axis2))+
  geom_hline(yintercept = 0)+
  geom_vline(xintercept = 0)+
  geom_point(aes(fill = Site), shape = 21, size = 3, show.legend = FALSE)+
  geom_label(data = centroid, aes(label = Site, fill = Site), size = 4, show.legend = FALSE)+
  scale_fill_manual(values = cols)+
  scale_colour_manual(values = cols)+
  labs(x = xlab, y = ylab)+
  ggtitle("P. meandrina DAPC")+
  ggtheme
```


#6. Admixture analysis 
```{r}
library(LEA)
## Here we are moving on to the LEA package in order to estimate K clusters and create admixture plots 
```

##6.1 Convert to geno format
```{r}
gl2geno(gl3, outfile = "gl_geno", outpath = getwd(), verbose = NULL)
```


##6.2 Plot variance 
```{r, include = FALSE}
pc = pca("gl_geno.lfmm", scale = TRUE)
tw = tracy.widom(pc)

#Plots the percentage of variance explained by eah component. You can look at the 'elbow' to inform the number of genetic clusers. It looks like ours is between 3-5.
plot(tw$percentage, pch = 19, col = "darkblue", cex = .8)
```


##6.3 SNMF algorithm
```{r, include = FALSE}
snmf1 = snmf("gl_geno.geno",
        K = 1:10,    #number of K ancestral populations to run
        entropy = TRUE,     #calculate cross-entropy
        repetitions = 10,    #10 repetitions for each K
        project = "new")

plot(snmf1, col = "blue", cex = 1.5, pch = 19)
```


##6.4 Extract cross-entropy
```{r}
# Extract the cross-entropy of all runs where K = 2
ce = cross.entropy(snmf1, K = 2)
ce
#choose lowest of the 10 runs for k =2
lowest.ce = which.min(ce)
lowest.ce
```


##6.5 Create qmatrix 
```{r}
#select k with lowest cross entropy and extract admixture results 
qmatrix = as.data.frame(Q(snmf1, K = 2, run = lowest.ce))
head(qmatrix)

# Label column names of qmatrix
ncol(qmatrix)
cluster_names = c()
for (i in 1:ncol(qmatrix)){
  cluster_names[i] = paste("Cluster", i)
}
cluster_names
colnames(qmatrix) = cluster_names
head(qmatrix)

# Add individual IDs
qmatrix$Ind = indNames(pmea_gen)

#Add site IDs
qmatrix$Site = pmea_gen$pop

#Convert dataframe to long format
qlong = melt(qmatrix, id.vars=c("Ind","Site"))
```


## 6.6 Admixture sorted by q-value
```{r}
library(ggplot2)
library(forcats)
library(ggthemes)
library(patchwork)

pal = colorRampPalette(c("gold","olivedrab"))
cols = pal(length(unique(qlong$variable)))

# Reorder factor levels within groups
qlong <- qlong %>%
  group_by(variable) %>%
  mutate(Ind = fct_reorder(Ind, value, .desc = TRUE)) %>%
  arrange(variable, Ind)

qlong <- qlong %>% mutate(variable = factor(variable, levels = c("Cluster 1", "Cluster 2"))) %>% 
  mutate(variable = recode(variable, "Cluster 1" = "PMCL1", "Cluster 2" = "PMCL2"))
```

```{r}
# Plot with reordered bars
admix.fig <- ggplot(qlong, aes(factor(Ind), value, fill = factor(variable))) +
  geom_col(color = "gray", linewidth = 0.1, width=1) +
  theme_minimal() +
    scale_fill_manual(values = cols)+
  labs(x = "Individual", y = "Admixture Proportion") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(add = 1)) +
  theme(
    panel.spacing.x = unit(0.1, "lines"),
    axis.text.x = element_blank(),
    panel.grid = element_blank())+
    theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.x=element_blank(),
        strip.text=element_text(colour="black", size=12),
        panel.grid=element_blank(),
        panel.background=element_blank(),
        legend.position="bottom",
        legend.title=element_blank(),
        legend.text=element_text(size=12)) +
    theme(plot.margin = margin(t = 30, r = 10, b = 30, l = 10, unit = "mm"))

  
admix.fig
```

##6.7 Admixture faceted by sector
```{r}
library(forcats)

# Relevel the "Site" variable
qlong$Site <- forcats::fct_relevel(qlong$Site, "CapeGrenville", "PCB", "Cairns", "Townsville","CapBunk", "Swains", "CS1", "CS2", "CS3", "CS4", "CS5", "CS6")

# Relevel the "Ind" variable by the "Site" variable in the data frame
qlong$Ind <- factor(qlong$Ind, levels = unique(qlong$Ind[order(qlong$Site)]))


admix.fig <- ggplot(qlong, aes(x = Ind, y = value, fill = variable)) +
  geom_col(color = "gray", linewidth = 0.1, width = 1) +
  facet_grid(~ Site, scales = "free_x", space = "free_x", switch = "x") +
  theme_minimal() +
  scale_fill_manual(values = cols) +
  labs(x = "Individual", y = "Admixture Proportion") +
  scale_y_continuous(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  theme(
    panel.spacing.x = unit(0.1, "lines"),
    panel.grid = element_blank(),
    axis.text.x = element_blank(),
    strip.text = element_text(colour = "black", size = 6),
    panel.background = element_blank(),
    legend.position = "bottom",
    legend.title = element_blank(),
    legend.text = element_text(size = 8),
    plot.margin = margin(t = 30, r = 10, b = 30, l = 10, unit = "mm"),
    panel.border = element_rect(color = "black", fill = NA, size = 0.5)
  )

admix.fig
```

##6.8 Admixture summary statistics
```{r}
#what is the proportion of PMCL1 in the northern GBR reefs? 
qlong %>% group_by(variable) %>% 
  filter(variable == "PMCL1") %>% 
  filter(Site %in% c("PCB", "Townsville")) %>% 
  summarise(mean = mean(value))

qlong %>% group_by(variable) %>% 
  filter(variable == "PMCL1") %>% 
 filter(Site %in% c("CS1", "CS2")) %>% 
  summarise(mean = mean(value))

qlong %>% group_by(variable) %>% 
  filter(variable == "PMCL1") %>% 
 filter(Site %in% c("Swains")) %>% 
  summarise(mean = mean(value))

qlong %>% group_by(variable) %>% 
  filter(variable == "PMCL2") %>% 
 filter(Site %in% c("CapBunk")) %>% 
  summarise(mean = mean(value))

qlong %>% group_by(variable) %>% 
  filter(variable == "PMCL2") %>% 
 filter(Site %in% c("CS3", "CS4")) %>% 
  summarise(mean = mean(value))

qlong %>% group_by(variable) %>% 
  filter(variable == "PMCL2") %>% 
 filter(Site %in% c("CS5", "CS6")) %>% 
  summarise(mean = mean(value))
```


#7. GEA data preparation

##7.1 Non-thermal environmental variables 
```{r}
#set up non-thermal variables. Remove any DHW-related variables. 
# i think will need to set up a dataframe with environmental variables only? Unsure. 
library(tidyverse)
library(vegan)
library(GGally)
library(corrplot)
library(car)
library(scales)
library(ggrepel)
library(gclus)
library(ape)

pmea.recifs <- read.csv("CSMP.GBR/pmea_recifs.csv") %>% 
  dplyr::select(-ID, -POI_LON, -POI_LAT, -DIST)

#select data of interest 
nontherm_var <- pmea.recifs %>% dplyr::select(POI_ID, LAT, LON, CHL_me_002, FE_me_002, O2_me_002, PH_me_002, NO3_me_002, PO4_me_002, SPM_me_002, SSS_me_002, SCV_me_002)

#scale and centre the data but not lat/lon
envdat.phy.scaled <- scale(nontherm_var[,-c(1:3)],
                          center=TRUE, # center data by subtracting column means 
                           scale=TRUE) # divide centered data by standard deviation

#run RDA function for PCA without the ID/lat/long
env.pca <- rda(envdat.phy.scaled[,-c(1:3)])  

#run the PCA 
env.pca

summary(env.pca, display = NULL)
screeplot(env.pca)

#extract first two PCs
selected_components <- scores(env.pca, choices=1:2, display='sites')

# Combine the selected principal components with the POI_ID (reef names)
proxy_data <- cbind(pmea.recifs["POI_ID"], selected_components)

envPC_data <- proxy_data %>% 
  rename(pop = POI_ID) %>% 
  rename(Env.PC1 = PC1) %>% 
  rename(Env.PC2 = PC2) 
# Print the first few rows of the proxy_data dataframe to verify the results
head(envPC_data)

```


## 7.2 Moran Eigenvector Maps for spatial environment 
```{r}
library('codep')
library('adespatial')
library('rnaturalearth')
library('rnaturalearthdata')
library('raster')

geo = read.csv('CSMP.GBR/pmea.coords.ch3.csv') %>% 
  rename(pop = ID) %>% 
  mutate(ID = 1:nrow(.)) %>% 
  mutate(ID = as.character(ID))
              
# calculate distance between sampling locations
DistSpatial=gcd.hf(geo[,2:3]) 

# compute dbMEMs
dbmem = dbmem(DistSpatial)

# get countries polygons for plotting
landPolygons = ne_countries(scale = 'medium')

# create colorpalette for MEM
paletteMEM = colorRampPalette(c('red','yellow','green2'))(20)

# select MEM of interest
par(mfrow=c(2,3))

for (i in 1:6) {
  
MoI = paste0('MEM',i)
plot(geo[,3:2], pch=21, bg=paletteMEM[cut(dbmem[,MoI], breaks = 20)])
plot(landPolygons, add=T, col='grey')

}

```
**Each dbMEM varies across sampling locations. Each eigenvector is descsribing the proximity between sampling sites at different levels (e.g. MEM1: north-south axis, MEM2: a few sites close together in the north, etc.)**


##7.3 Extract dbMEMs
```{r}
# Convert dbmem to a data frame
dbmem_df <- as.data.frame(dbmem) %>% 
  tibble::rownames_to_column(var = "ID")

# Left join 'dbmem_df' with the 'geo' data frame based on the 'ID' column
dbmem_with_reef <- dbmem_df %>%  left_join(geo)

dbmem_pca <- dbmem_with_reef %>% dplyr::select(c(pop, MEM1, MEM2, MEM3, MEM4, MEM5, MEM6))
```


##7.4 Thermal variables 
```{r}
#extract thermal variables and create new dataframe
therm_var <- pmea.recifs %>% dplyr::select(POI_ID, DHW_me_002, DHW_sd_002, SST_me_002, SST_sd_002) %>% rename(pop = POI_ID) 
```


##7.5 Genetic SNP tree 
```{r}
library(adegenet)
library(usedist)
library(vegan)

#left join genetic metadata and environmental variables
pmea.meta <- read.csv("pmea.meta2.csv") %>% 
  left_join(., dbmem_pca) %>% 
  left_join(., therm_var) %>% 
  left_join(., envPC_data) %>% 
  filter(Ind != c('JAN2019_13-124_P. verrucosa_103', 'April2021-Kelso-P. verrucosa-17','P ver 221', 'P ver 371', 'P ver 372', 'P ver 291', 'P ver 044'))


#calculate distance matrix 
dist_pmea <- gl.dist.ind(gl3, method = "euclidean", scale = TRUE)
#convert to dist. object
du_pmea <- as.dist(dist_pmea)

pmea.meta.dist <- pmea.meta %>% 
  filter(Ind %in% ind_coords.full$Ind) %>% 
    tibble::column_to_rownames(var = "Ind") 

#(SNP = response variable)
dist_pmea_ordered <- dist_subset(dist_pmea, rownames(pmea.meta.dist))
```


#8. dbRDA environmental models

##8.1 PCoA
```{r}
#join all environmental data together
library(tidyverse)
pcoa.pmea <- cmdscale(dist_pmea, eig = TRUE) #classic PCoA 

pcoa.pmeaXY <- data.frame(pcoa.pmea$points) %>% 
    rownames_to_column(var = "Ind") %>% 
  left_join(., pmea.meta) %>% 
  mutate(Ind = as.factor(Ind)) %>% 
  mutate(sector = as.factor(sector))
  

pcoa_plot <-pcoa.pmeaXY %>%
  ggplot(aes(X1, X2, fill = sector)) + 
  geom_point(alpha = 1, shape = 21, size = 3) +
  theme(legend.position = "right", aspect.ratio = 1, text = element_text(size = 10))

pcoa_plot

pcoa_result <- pcoa.pmeaXY[, c("X1", "X2")]
```

##Full correlation variable matrix 
```{r}
cm <- cor(pmea.meta.dist %>% dplyr::select(lat, lon, MMM,MEM1, MEM2, MEM3, MEM4, MEM5, MEM6, DHW_me_002, SST_me_002, Env.PC1, Env.PC2))
corrplot(cm)
```


##8.2 Ordistep and dbRDA models 
```{r}
ord_pmea_full <- dbrda(dist_pmea_ordered ~ lat + lon + MMM + MEM1 + MEM2 + MEM3 + MEM4 + MEM5 + MEM6 + DHW_me_002 + SST_me_002 + Env.PC1 + Env.PC2, data = pmea.meta.dist)


sort(vif.cca(ord_pmea_full)) 
print(ord_pmea_full)
RsquareAdj(ord_pmea_full)
#will need to reduce these as some are collinear. 
#MEM1 and MEM2 are most significant so will keep those as conditional factors in the dbRDA 
```


##8.3 Reduced correlation plots 
```{r}
cm.red <- cor(pmea.meta.dist %>% dplyr::select(MEM1, MEM2, MMM, DHW_me_002, Env.PC1, Env.PC2))
corrplot(cm.red)
```

- Remove MEM3, MEM4, MEM5, MEM6 (because MEM1 and MEM2 more significant)
- Remove SST because MMM should account for climatology, and DHW will account for thermal history
- Remove lat and long because highly correlated with MMM and MEMs will account for spatial variation 

```{r}
ord_pmea_red <- dbrda(dist_pmea_ordered ~  MEM1 + MEM2 + DHW_me_002 + Env.PC1 + Env.PC2, data = pmea.meta.dist)

print(ord_pmea_red)
RsquareAdj(ord_pmea_red)
sort(vif.cca(ord_pmea_red)) 
summary(ord_pmea_red)

##thermal model 
ord_pmea_thermal <- dbrda(dist_pmea_ordered ~ MMM + DHW_me_002 + Condition(MEM1 + MEM2 + lon + Env.PC1 + Env.PC2), data = pmea.meta.dist)

print(ord_pmea_thermal)
RsquareAdj(ord_pmea_thermal)

##non-thermal environment model 
ord_pmea_nonthermal <- dbrda(dist_pmea_ordered ~  Env.PC1 + Env.PC2 + Condition(MEM1 + MEM2 + MMM + DHW_me_002 + lon), data = pmea.meta.dist)

print(ord_pmea_nonthermal)
RsquareAdj(ord_pmea_nonthermal)

##geographic model 
ord_pmea_geo <- dbrda(dist_pmea_ordered ~ MEM1 + MEM2 +  lon + Condition(Env.PC1 + Env.PC2 + MMM + DHW_me_002), data = pmea.meta.dist)

print(ord_pmea_geo)
RsquareAdj(ord_pmea_geo)

# Use ordistep to run a backward stepwise model. This will reduce the model to the most significant parameters 
ordi_pmea <- ordistep(ord_pmea_red, direction = "backward", permutations = 999)
anova(ordi_pmea, by = 'margin')

#ordi_pmea_nonthermal <- ordistep(ord_pmea_nonthermal, direction = "backward", permutations = 999)
#anova(ordi_pmea_nonthermal, by = 'margin')

#ordi_pmea_thermal <- ordistep(ord_pmea_thermal, direction = "backward", permutations = 999)
#anova(ordi_pmea_thermal, by = 'margin')

#ordi_pmea_geo <- ordistep(ord_pmea_geo, direction = "backward", permutations = 999)
#anova(ordi_pmea_geo, by = 'margin')

### ANOVA outputs ###

#with full model 
#Model: dbrda(formula = dist_pmea_ordered ~ DHW_me_002 + Env.PC1, data = pmea.meta.dist)
  #          Df SumOfSqs      F Pr(>F)    
#DHW_me_002   1   0.5477 4.1868  0.001 ***
#Env.PC1      1   0.6734 5.1478  0.001 ***
#Residual   105  13.7346         

#with nonthermal model
#Model: dbrda(formula = dist_pmea_ordered ~ Env.PC1 + Condition(MEM1 + MEM2 + MMM + DHW_me_002 + lon), data = pmea.meta.dist)
         # Df SumOfSqs      F Pr(>F)   
#Env.PC1    1   0.2049 1.5721  0.003 **
#Residual 101  13.1649  

#with thermal model
#Model: dbrda(formula = dist_pmea_ordered ~ MMM + Condition(MEM1 + MEM2 + lon + Env.PC1 + Env.PC2), data = pmea.meta.dist)
     #     Df SumOfSqs      F Pr(>F)   
#MMM        1   0.2015 1.5439  0.008 **
#Residual 101  13.1791 

#with geographic model
#Model: dbrda(formula = dist_pmea_ordered ~ lon + Condition(Env.PC1 + Env.PC2 + MMM + DHW_me_002), data = pmea.meta.dist)
     #     Df SumOfSqs      F Pr(>F)   
#lon        1    0.180 1.3793   0.01 **
#Residual 102   13.313                 
```
*Can create a table with each model and the dbRDA outputs*


## 8.3 Extract variance
```{r}
# Extract eigenvalues
eigenvalues <- ord_pmea_red$CCA$eig

# Calculate proportion of variance explained
explained_variance <- eigenvalues / sum(eigenvalues)

# Create a bar plot to visualize explained variance
barplot(explained_variance, 
        main = "Explained Variance per Axis",
        xlab = "Axis",
        ylab = "Proportion Explained",
        names.arg = seq_along(explained_variance))

summary(ord_pmea_red)

# Custom x and y labels
xlab = paste("Axis 1 (52.3%)")
ylab = paste("Axis 2 (10.3%)")
```
**For P. meandrina, the first principal component explains 49.0% of variance. The main drivers of genetic variation in allele frequencies are DHW and non-thermal PC1.** 


##8.4 Extract vectors/scores
```{r}
#ONLY run this line first time - otherwise won't work 
pmea.meta.dist <- pmea.meta.dist %>% 
 tibble::rownames_to_column(var = "Ind")

#extract scores (values assigned to Ind) from dbRDA and left-join metadata 
pmea_scores <- as.data.frame(scores(ordi_pmea, display = "sites")) %>%
  tibble::rownames_to_column(var = "Ind") %>%
  left_join(., pmea.meta.dist)

#extract vectors from dbRDA 
pmea_vectors <- as.data.frame(ordi_pmea$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

pmea_scores <- pmea_scores %>% 
  mutate(sector = factor(sector, levels = c("CapeGrenville", "PCB", "Cairns", "Townsville", "CapBunker", "Swains", "CS1", "CS2", "CS3", "CS4", "CS5", "CS6"))) %>% 
  mutate(region = factor(region))

```



##8.5 Define sector colours 
```{r}
reef_names <- c("CapeGrenville", "PCB", "Cairns", "Townsville", "Swains", "CapBunker", "CS1", "CS2", "CS3", "CS4", "CS5", "CS6")

reef_pal2 <- c("#aa3653", "#d34467", "#dc6986", "#a15284", "#c867a5", "#d386b7",
               "#3f5d82", "#4f73a1", "#729fb4", "#1c7873", "#27958f", "#4eaaa6")

names(reef_pal2) <- reef_names

```

##8.6 Plot RDA by region
```{r}
mycols <- c("#E6F598", "#66C2A5")

library(ggrepel)
#produce dbRDA plot 
rda_sector <- pmea_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = factor(region)), size = 3, shape = 21) +
      geom_label_repel(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "black") +
        scale_fill_manual(values = mycols) +
        labs(x = xlab, y = ylab) +
     theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 12)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme_PCA

rda_sector
```

##7.6 dbRDA by sector
```{r}
library(ggrepel)
#produce dbRDA plot 
rda_sector <- pmea_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "black") +
   geom_point(aes(fill = factor(sector)), size = 3, shape = 21) +
      geom_label_repel(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
        scale_fill_manual(values = reef_pal2) +
    labs(x = xlab, y = ylab) +
     theme(legend.position = "none") +
    theme(aspect.ratio = 1, text = element_text(size = 12)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme_PCA 

rda_sector

```

##8.7 Plot RDA by latitude

```{r}
# Define the common color scale limits
color_limits <- c(13, 24)

# Create custom breaks with breaks every 3 numbers
color_breaks <- seq(13, 24, by = 3)  # Specify the desired breaks here

# Create a custom color scale with the "Spectral" palette and specified limits
common_scale <- scale_fill_gradientn(colors = colorRampPalette(brewer.pal(11, "Spectral"))(100),
                                      limits = color_limits,
                                      breaks = color_breaks)

# Function to manually reverse the legend
reverse_legend <- function(p) {
  p + theme(legend.position = "right") +
    guides(fill = guide_colorbar(reverse = TRUE))  # Reverse the colorbar guide
}

```


```{r}
rda_lat <- pmea_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = lat), size = 3, shape = 21) +
      geom_label_repel(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "black") +
      common_scale +  # Use the common color scale here
      labs(x = xlab, y = ylab) +
     theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 12)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme_PCA


rda_lat
```

##8.8 Plot RDA by longitude 
```{r}
rda_long <- pmea_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = lon), size = 3, shape = 21) +
      geom_label_repel(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "black") +
  scale_fill_distiller(palette = "BrBG", trans = "reverse") + 
        labs(x = xlab, y = ylab) +
  theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 12)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme_PCA

rda_long
```


##8.8 dbRDA by DHW
```{r}
rda_DHW <- pmea_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = DHW_me_002), size = 3, shape = 21) +
        geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "black") +
      geom_label_repel(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
  scale_fill_distiller(palette = "RdYlBu") +     
      labs(x = xlab, y = ylab) +
  theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 12)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme_PCA 

rda_DHW

```

##7.8 dbRDA by MMM
```{r}
rda_MMM <- pmea_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = MMM), size = 3, shape = 21) +
      geom_label_repel(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "black") +
  scale_fill_distiller(palette = "Spectral") +     
      labs(x = xlab, y = ylab) +
  theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 12)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme_PCA

rda_MMM
```

```{r}
rda_DHW + rda_sector
```


##8.9 Figure 3A
```{r}
rda_sector / rda_long / rda_lat
```



#9 partial RDA  
**Here we are going to run redundancy analysis using a different approach. We will be using allele frequencies at the population level instead of euclidean SNP distances at the individual level.** 

##9.1 Calcualte allele frequencies
```{r}
# Calculate allele frequencies for each site. I created a separate gen.ind so we can measure population level allele frequencies instead of by sector. this is pver_gen.pop
allele_freqs = data.frame(rraf(pmea_gen.pop, by_pop=TRUE, correction = FALSE), check.names = FALSE)

# Keep only the first of the two alleles for each SNP (since p=1-q).
allele_freqs = allele_freqs[, seq(1, dim(allele_freqs)[2], 2)]

# Export allele frequencies
write.csv(allele_freqs, file = "allele_freqs.csv", row.names = TRUE)
```

##9.2 Neutral population structure PCs 

```{r}
## Running a PCA on neutral genetic markers
pca_neutral <- rda(allele_freqs[,-1], scale=T) # PCA in vegan uses the rda() call without any predictors
```


Screeplot of the PCA eigenvalues:

```{r, message=FALSE, warning=FALSE, results='hide', eval=TRUE}
screeplot(pca_neutral, type = "barplot", npcs=10, main="PCA Eigenvalues")
```


```{r}
## Neutral population structure table
PCs <- scores(pca_neutral, choices=c(1:3), display="sites", scaling=0)
PopStruct <- data.frame(pop = allele_freqs[,1], PCs)
colnames(PopStruct) <- c("pop", "PC1", "PC2", "PC3")

pop.structure <- PopStruct %>% dplyr::select(-"pop") %>% 
  rename(neutralPC1 = PC1) %>% 
  rename(neutralPC2 = PC2) %>% 
  rename(neutralPC3 = PC3)
```


##9.2 dbMEMs
```{r}
library('codep')
library('adespatial')
library('rnaturalearth')
library('rnaturalearthdata')
library('raster')

geo = read.csv('CSMP.GBR/pmea.coords.ch3.csv') %>% 
  rename(pop = ID) %>% 
  mutate(ID = 1:nrow(.)) %>% 
  mutate(ID = as.character(ID))
              
# calculate distance between sampling locations
DistSpatial=gcd.hf(geo[,2:3]) 

# compute dbMEMs
dbmem = dbmem(DistSpatial)

# get countries polygons for plotting
landPolygons = ne_countries(scale = 'medium')

# create colorpalette for MEM
paletteMEM = colorRampPalette(c('red','yellow','green2'))(20)

# select MEM of interest
par(mfrow=c(2,3))

for (i in 1:6) {
  
MoI = paste0('MEM',i)
plot(geo[,3:2], pch=21, bg=paletteMEM[cut(dbmem[,MoI], breaks = 20)])
plot(landPolygons, add=T, col='grey')

}

```
**Each dbMEM varies across sampling locations. Each eigenvector is descsribing the proximity between sampling sites at different levels (e.g. MEM1: north-south axis, MEM2: a few sites close together in the north, etc.)**


##9.3 Extract dbMEMs
```{r}
# Convert dbmem to a data frame
dbmem_df <- as.data.frame(dbmem) %>% 
  tibble::rownames_to_column(var = "ID")

# Left join 'dbmem_df' with the 'geo' data frame based on the 'ID' column
dbmem_with_reef <- dbmem_df %>%  left_join(geo)

dbmem_pca <- dbmem_with_reef %>% dplyr::select(c(pop, MEM1, MEM2, MEM3, MEM4, MEM5, MEM6))
```



##Read in environmental data 
```{r}
#let's get a list of the variables we want to include in the GEA analysis 
pmea.recifs <- read.csv("CSMP.GBR/pmea_recifs.csv") %>% 
  dplyr::select(-ID, -POI_LON, -POI_LAT, -DIST)

pmea.env <- pmea.recifs %>% dplyr::select(POI_ID, CHL_me_002, FE_me_002, O2_me_002, PH_me_002, NO3_me_002, PO4_me_002, SPM_me_002, SSS_me_002, SCV_me_002, DHW_me_002, SST_me_002) %>% 
      rename(pop = POI_ID) 


pmea.meta.ind <- read.csv("pmea.meta2.csv") %>% dplyr::select(Ind, pop, region, sector, lat, lon, MMM)

#only one individual in Kelso so we will remove from the pop allele frequencies analysis 
env <- pmea.meta.ind %>% left_join(pmea.env) %>% 
  filter(pop != "Kelso")

#change region/pop/sector to factor
env$pop <- as.factor(env$pop)
env$region <- as.factor(env$region)
env$sector <- as.factor(env$sector)

str(env)


pop.env <- env %>% group_by(pop) %>% 
  summarise(
    pop.lat = mean(lat),
    pop.lon = mean(lon),
    pop.MMM = mean(MMM),
    pop.CHL = mean(CHL_me_002),
    pop.FE = mean(FE_me_002),
    pop.O2 = mean(O2_me_002),
    pop.PH = mean(PH_me_002),
    pop.NO3 = mean(NO3_me_002),
    pop.PO4 = mean(PO4_me_002),
    pop.SPM = mean(SPM_me_002),
    pop.SSS = mean(SSS_me_002),
    pop.SCV = mean(SCV_me_002),
    pop.DHW = mean(DHW_me_002),
    pop.SST = mean(SST_me_002)
  )

write.csv(pop.env, file="environmental_data.csv", row.names = FALSE)

```


```{r}
# Import environmental data and make reef the row name. 
env.raw = read.csv("environmental_data.csv", row.names = 1)
env.raw <- round(env.raw, digits = 2)
```


```{r}
#set up non-thermal variables. Remove any DHW-related variables. 
# i think will need to set up a dataframe with environmental variables only? Unsure. 
library(tidyverse)
library(vegan)
library(GGally)
library(corrplot)
library(car)
library(scales)
library(ggrepel)
library(gclus)
library(ape)

env.scaled = read.csv("environmental_data.csv")

#select data of interest and define separate dataframes for each 
pop.therm <- env.scaled %>% dplyr::select(pop.MMM, pop.DHW, pop.SST)

pop.nontherm <- env.scaled %>% dplyr::select(-pop.MMM, -pop.DHW, -pop.SST)

pop.latlon <- env.scaled %>% dplyr::select(pop.lat, pop.lon)

#scale and centre the data but not lat/lon
envdat.phy.scaled <- scale(pop.nontherm[,-c(1:3)],
                          center=TRUE, # center data by subtracting column means 
                           scale=TRUE) # divide centered data by standard deviation

#run RDA function for PCA without the ID/lat/long
env.pca <- rda(envdat.phy.scaled[,-c(1:3)])  

#run the PCA 
env.pca

summary(env.pca, display = NULL)
screeplot(env.pca)

#extract first two PCs
selected_components <- scores(env.pca, choices=1:2, display='sites')

# Combine the selected principal components with the POI_ID (reef names)
proxy_data <- cbind(env.scaled["pop"], selected_components)

envPC_data <- proxy_data %>% 
  rename(Env.PC1 = PC1) %>% 
  rename(Env.PC2 = PC2) 
# Print the first few rows of the proxy_data dataframe to verify the results
head(envPC_data)
```



```{r}
env.dbmem <- cbind(envPC_data, dbmem)
env.dbmem <- cbind(env.dbmem, pop.therm)
#env.dbmem <- cbind(env.dbmem, pop.structure)
#env.dbmem <- cbind(env.dbmem, pop.latlon)

env.dbmem <- env.dbmem %>% rownames_to_column("site") %>% dplyr::select(-site) %>% 
  column_to_rownames("pop")
```



```{r}
library(vegan)
# Use backward selection to identify significant thermal environmental variables
ord_pmea_af <- dbrda(allele_freqs ~ Env.PC1 + Env.PC2 + pop.DHW + pop.MMM + MEM1 + MEM2 + MEM3 + MEM4 + MEM5 + MEM6, data = env.dbmem)


sort(vif.cca(ord_pmea_af)) 

ord_pmea_red <- dbrda(allele_freqs ~ Env.PC1 + Env.PC2 + pop.DHW + pop.MMM + MEM1 + MEM2 + MEM3 + MEM4 + MEM5 + MEM6, data = env.dbmem)


os_pmea_back <- ordistep(ord_pmea_red, direction = "backward", permutations = 999)
anova(os_pmea_back, by = 'margin')


#Model outputs 

##Full model 
#Model: dbrda(formula = allele_freqs ~ Env.PC1 + pop.DHW, data = env.dbmem)
#         Df Variance      F Pr(>F)    
#Env.PC1   1   4.1597 3.7419  0.001 ***
#pop.DHW   1   4.3547 3.9174  0.001 ***
#Residual 17  18.8979         



pred <- env.dbmem %>% dplyr::select(Env.PC1, Env.PC2, MEM1, MEM2, pop.MMM, pop.DHW)
```


```{r}
library(vegan)
pmea.rda <- rda(allele_freqs ~ ., data=pred, scale=T)
pmea.rda

pmea.rda.nontherm <- rda(allele_freqs ~ Env.PC1 + Env.PC2 + Condition(MEM1 + MEM2 + pop.MMM + pop.DHW), data=pred, scale=T)

pmea.rda.therm <- rda(allele_freqs ~ pop.MMM + pop.DHW + Condition(MEM1 + MEM2 + Env.PC1 + Env.PC2), data=pred, scale=T)

pmea.rda.geo <- rda(allele_freqs ~ MEM1 + MEM2 + Condition(pop.MMM + pop.DHW + Env.PC1 + Env.PC2), data=pred, scale=T)

#pmea.rda.neutral <- rda(allele_freqs ~ neutralPC1 + neutralPC2 + Condition(pop.MMM + pop.DHW + Env.PC1 + Env.PC2 + MEM1 + MEM2), data=pred, scale=T)
```


```{r}
summary(pmea.rda)
summary(pmea.rda.therm)
summary(pmea.rda.nontherm)
  #thermal metrics are the strongest predictor which is cool!
summary(pmea.rda.geo)
```

```{r}
anova(pmea.rda)
anova(pmea.rda.therm)
anova(pmea.rda.nontherm)
  #thermal metrics are the strongest predictor which is cool!
anova(pmea.rda.geo)
```


```{r}
RsquareAdj(pmea.rda)
RsquareAdj(pmea.rda.nontherm)
RsquareAdj(pmea.rda.therm)  #thermal metrics are the strongest predictor which is cool!
RsquareAdj(pmea.rda.geo)
```


##Let's create the same GGPlot with allele frequencies instead of Euclidean SNP distances. 
##8.4 Extract vectors/scores
```{r}
#ONLY run this line first time - otherwise won't work 
pmea.allele.dist <- allele_freqs %>% 
 tibble::rownames_to_column(var = "Ind")

#extract scores (values assigned to Ind) from dbRDA and left-join metadata 
pmea_scores <- as.data.frame(scores(ord_pmea_red, display = "sites")) %>%
  tibble::rownames_to_column(var = "Ind") %>%
  left_join(., pmea.allele.dist)

#extract vectors from dbRDA 
pmea_vectors <- as.data.frame(ord_pmea_red$CCA$biplot) %>%
  tibble::rownames_to_column(var = "factors")

pmea.allele.dist$Ind

pmea_scores <- pmea_scores %>% 
  mutate(sector = factor(Ind, levels = c("13-124", "21-550", "22-084","Bougainville", "Chicken", "Chilcott", "Chinaman", "Corbett", "Davie", "Davies", "Fitzroy", "Frederick", "Holmes", "Hoskyns", "Lady Musgrave", "Marion", "Moore", "Saumarez", "Willis", "Wreck"))) 

```



```{r}
library(ggrepel)
#produce dbRDA plot 
rda_sector <- pmea_scores %>%
    ggplot(aes(x = dbRDA1, y = dbRDA2)) +
      geom_point(aes(fill = factor(sector)), size = 3, shape = 21) +
      geom_label_repel(data = pmea_vectors, aes(x = dbRDA1, y = dbRDA2, label = factors), box.padding = 0.5, size = 4, segment.colour = NA) +
      geom_segment(data = pmea_vectors, aes(x = 0, xend = dbRDA1, y = 0, yend = dbRDA2), 
      size = 0.5, arrow = arrow(length = unit(0.5, "cm")), colour = "black") +
        scale_fill_manual(values = reef_pal2) +
        labs(x = xlab, y = ylab) +
     theme(legend.position = "right") +
    theme(aspect.ratio = 1, text = element_text(size = 12)) +
  theme(plot.background = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank()) +
  theme_PCA

rda_sector
```



```{r}
load.rda <- scores(pmea.rda, choices=c(1:3), display="species")  # Species scores for the first three constrained axes
```



```{r}
hist(load.rda[,1], main="Loadings on RDA1")
hist(load.rda[,2], main="Loadings on RDA2")
hist(load.rda[,3], main="Loadings on RDA3") 
```


```{r}
#function to determine outliers. 
outliers <- function(x,z){
  lims <- mean(x) + c(-1, 1) * z * sd(x)     # find loadings +/-z sd from mean loading     
  x[x < lims[1] | x > lims[2]]               # locus names in these tails
}
```

```{r}
cand1 <- outliers(load.rda[,1],2.5) # 38
cand2 <- outliers(load.rda[,2],2.5) # 69
cand3 <- outliers(load.rda[,3],2.5) # 34

ncand <- length(cand1) + length(cand2) + length(cand3)
ncand

#220 SNPs if we use SD of 2. If we use 2.5 then we only retain 83. 
```

```{r}
cand1 <- cbind.data.frame(rep(1,times=length(cand1)), names(cand1), unname(cand1))
cand2 <- cbind.data.frame(rep(2,times=length(cand2)), names(cand2), unname(cand2))
cand3 <- cbind.data.frame(rep(3,times=length(cand3)), names(cand3), unname(cand3))

colnames(cand1) <- colnames(cand2) <- colnames(cand3) <- c("axis","snp","loading")

cand <- rbind(cand1, cand2, cand3)
cand$snp <- as.character(cand$snp)
```


```{r}
# Initialize a matrix to store correlations
cor_matrix <- matrix(nrow = nrow(cand), ncol = ncol(pred))
colnames(cor_matrix) <- colnames(pred)

# Loop through each candidate SNP
for (i in 1:nrow(cand)) {
  snp_name <- cand[i, 2]
  snp_gen <- allele_freqs[, snp_name]
  
  # Calculate correlations with each predictor
  cor_matrix[i, ] <- sapply(1:ncol(pred), function(j) cor(pred[, j], snp_gen))
}

# Combine the correlation matrix with the candidate data
cand <- cbind.data.frame(cand, cor_matrix)
head(cand)
```


```{r}
length(cand$snp[duplicated(cand$snp)])  # 7 duplicate detections
```

```{r}
foo <- cbind(cand$axis, duplicated(cand$snp)) 
table(foo[foo[,1]==1,2]) # no duplicates on axis 1
```

```{r}
table(foo[foo[,1]==2,2]) #  1 duplicates on axis 2
```


```{r}
table(foo[foo[,1]==3,2]) # 4 duplicates on axis 3
```

```{r}
cand <- cand[!duplicated(cand$snp),] # remove duplicate detections
```


```{r}
for (i in 1:length(cand$snp)) {
  bar <- cand[i,]
  cand[i,12] <- names(which.max(abs(bar[4:9]))) # gives the variable
  cand[i,13] <- max(abs(bar[4:9]))              # gives the correlation
}

colnames(cand)[12] <- "predictor"
colnames(cand)[13] <- "correlation"

table(cand$predictor) 
```



```{r}
sel <- cand$snp
env <- cand$predictor
env[env=="Env.PC1"] <- '#1f78b4'
env[env=="Env.PC2"] <- '#a6cee3'
env[env=="MEM1"] <- '#6a3d9a'
env[env=="MEM2"] <- '#e31a1c'
env[env=="pop.DHW"] <- '#33a02c'
env[env=="pop.MMM"] <- '#ffff33'
#env[env=="pop.lat"] <- '#fb9a99'
#env[env=="pop.SST"] <- '#b2df8a'

# color by predictor:
col.pred <- rownames(pmea.rda$CCA$v) # pull the SNP names

for (i in 1:length(sel)) {           # color code candidate SNPs
  foo <- match(sel[i],col.pred)
  col.pred[foo] <- env[i]
}

col.pred[regexpr('#.*', col.pred)==-1] <- '#f1eef6' # non-candidate SNPs
empty <- col.pred
empty[grep("#f1eef6",empty)] <- rgb(0,1,0, alpha=0) # transparent
empty.outline <- ifelse(empty=="#00FF0000","#00FF0000","gray32")
bg <- c('#1f78b4','#a6cee3','#6a3d9a','#e31a1c','#33a02c','#ffff33','#fb9a99','#b2df8a')
```


```{r}
# axes 1 & 2
plot(pmea.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-.5,.5))
points(pmea.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3)
points(pmea.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3)
text(pmea.rda, scaling=3, display="bp", col="#0868ac", cex=1)
legend("bottomright", legend=c("Env.PC1","Env.PC2","MEM1","MEM2","pop.DHW","pop.MMM"), bty="n", col="gray32", pch=21, cex=1, pt.bg=bg)

# axes 1 & 3
plot(pmea.rda, type="n", scaling=3, xlim=c(-1,1), ylim=c(-.5,.5), choices=c(1,3))
points(pmea.rda, display="species", pch=21, cex=1, col="gray32", bg=col.pred, scaling=3, choices=c(1,3))
points(pmea.rda, display="species", pch=21, cex=1, col=empty.outline, bg=empty, scaling=3, choices=c(1,3))
text(pmea.rda, scaling=3, display="bp", col="#0868ac", cex=1, choices=c(1,3))
legend("bottomright", legend=c("Env.PC1","Env.PC2","MEM1","MEM2","pop.DHW","pop.MMM"), bty="n", col="black", pch=21, cex=1, pt.bg=bg)

```


```{r}
intersetcor(pmea.rda)[,1:3]
```
**Generally, SNPs on axis 1 are associated most with longitude, SNPs on axis 2 are associated with MEM2, and SNPs on axis 3 are associated with SST and MMM.** Cool!!! 



##PCAdapt to identify outlier loci 
```{r}
library(pcadapt)

path_to_file <- "gl_geno.lfmm"
filename <- read.pcadapt(path_to_file, type = "lfmm")

x <- pcadapt(input = filename, K = 20)
plot(x, option = "screeplot")
plot(x, option = "screeplot", K = 10)

```

```{r}
x <- pcadapt(filename, K = 2)
summary(x)

plot(x , option = "manhattan")

```

```{r}
plot(x, option = "qqplot")

#This plot confirms that most of the p-values follow the expected uniform distribution. However, the smallest p-values are smaller than expected confirming the presence of outliers.
```


```{r}
hist(x$pvalues, xlab = "p-values", main = NULL, breaks = 50, col = "orange")
```

```{r}
plot(x, option = "stat.distribution")
```

```{r}
library(qvalue)
qval <- qvalue(x$pvalues)$qvalues
alpha <- 0.1
outliers <- which(qval < alpha)
length(outliers)
```

```{r}
padj <- p.adjust(x$pvalues,method="BH")
alpha <- 0.1
outliers <- which(padj < alpha)
length(outliers)

```

```{r}
padj <- p.adjust(x$pvalues,method="bonferroni")
alpha <- 0.1
outliers <- which(padj < alpha)
length(outliers)
#get less outliers using the bonferroni correciton. 
```


##How do we find out the loci for each outlier? In outflank it is default. Here it just gives a number. 







##ADMIXTURE AT POPULATION LEVEL 
#6. Admixture analysis 
```{r}
library(LEA)
## Here we are moving on to the LEA package in order to estimate K clusters and create admixture plots 
```

##6.1 Convert to geno format
```{r}
gl2geno(gl3.pop, outfile = "gl_geno", outpath = getwd(), verbose = NULL)
```


##6.2 Plot variance 
```{r, include = FALSE}
pc = pca("gl_geno.lfmm", scale = TRUE)
tw = tracy.widom(pc)

#Plots the percentage of variance explained by eah component. You can look at the 'elbow' to inform the number of genetic clusers. It looks like ours is between 3-5.
plot(tw$percentage, pch = 19, col = "darkblue", cex = .8)
```


##6.3 SNMF algorithm
```{r, include = FALSE}
snmf1 = snmf("gl_geno.geno",
        K = 1:10,    #number of K ancestral populations to run
        entropy = TRUE,     #calculate cross-entropy
        repetitions = 10,    #10 repetitions for each K
        project = "new")

plot(snmf1, col = "blue", cex = 1.5, pch = 19)
```


##6.4 Extract cross-entropy
```{r}
# Extract the cross-entropy of all runs where K = 2
ce = cross.entropy(snmf1, K = 2)
ce
#choose lowest of the 10 runs for k =2
lowest.ce = which.min(ce)
lowest.ce
```


##6.5 Create qmatrix 
```{r}
#select k with lowest cross entropy and extract admixture results 
qmatrix = as.data.frame(Q(snmf1, K = 2, run = lowest.ce))
head(qmatrix)

# Label column names of qmatrix
ncol(qmatrix)
cluster_names = c()
for (i in 1:ncol(qmatrix)){
  cluster_names[i] = paste("Cluster", i)
}
cluster_names
colnames(qmatrix) = cluster_names
head(qmatrix)

# Add individual IDs
qmatrix$Ind = indNames(pmea_gen.pop)

#Add site IDs
qmatrix$Site = pmea_gen.pop$pop

#Convert dataframe to long format
qlong = melt(qmatrix, id.vars=c("Ind","Site"))
```



##Pie chart map building

```{r}
clust_pal <- c("#E3856B", "#EEC95C")
clust_names <- c("Cluster 1", "Cluster 2")
names(clust_pal) <- clust_names

pmea.pie <- qlong %>% 
  group_by(Site, variable) %>% 
  dplyr::summarise(mean = mean(value))

pmea.pie %>% arrange(variable)


ggplot(pmea.pie, aes(x = "", y = mean, fill = factor(variable))) +
  geom_bar(position="fill", stat="identity") + coord_polar("y")+
  facet_wrap( ~ Site) +
  scale_fill_manual(values = clust_pal) +
  theme_classic()+
  theme(legend.position = c(1.1, 0.85), 
        axis.title=element_blank(), 
        axis.line=element_blank(),
        axis.ticks=element_blank(), 
        axis.text=element_blank(),
        plot.background = element_blank(), 
        plot.title=element_text(color="black",size=10,face="plain",hjust=0.5),
        strip.background = element_blank())

save(pmea.pie, file = "pmea.pie.RData")

```

